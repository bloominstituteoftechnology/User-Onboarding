import * as React from 'react';
import { FormikProps, GenericFieldHTMLAttributes, FieldMetaProps, FieldInputProps, FieldValidator } from './types';
export interface FieldProps<V = any> {
    field: FieldInputProps<V>;
    form: FormikProps<V>;
    meta: FieldMetaProps<V>;
}
export interface FieldConfig {
    /**
     * Field component to render. Can either be a string like 'select' or a component.
     */
    component?: keyof JSX.IntrinsicElements | React.ComponentType<FieldProps<any>> | React.ComponentType;
    /**
     * Component to render. Can either be a string e.g. 'select', 'input', or 'textarea', or a component.
     */
    as?: React.ComponentType<FieldProps<any>['field']> | keyof JSX.IntrinsicElements | React.ComponentType;
    /**
     * Render prop (works like React router's <Route render={props =>} />)
     * @deprecated
     */
    render?: (props: FieldProps<any>) => React.ReactNode;
    /**
     * Children render function <Field name>{props => ...}</Field>)
     */
    children?: ((props: FieldProps<any>) => React.ReactNode) | React.ReactNode;
    /**
     * Validate a single field value independently
     */
    validate?: FieldValidator;
    /**
     * Field name
     */
    name: string;
    /** HTML input type */
    type?: string;
    /** Field value */
    value?: any;
    /** Inner ref */
    innerRef?: (instance: any) => void;
}
export declare type FieldAttributes<T> = GenericFieldHTMLAttributes & FieldConfig & T & {
    name: string;
};
export declare function useField<Val = any>(propsOrFieldName: string | FieldAttributes<Val>): [FieldInputProps<Val>, FieldMetaProps<Val>];
export declare function Field({ validate, name, render, children, as: is, // `as` is reserved in typescript lol
component, ...props }: FieldAttributes<any>): any;
